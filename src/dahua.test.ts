import axios, { AxiosRequestConfig, AxiosResponse } from 'axios'
import { Readable } from 'stream'
import { DahuaAlarm, DahuaEvents } from './dahua'

describe('Dahua Events', () => {

  beforeEach(() => {
    jest.mock('axios')
    // Set axios.request to a mock function.
    axios.request = jest.fn()
  })


  test('Should successfully authenticate with digest auth', async () => {
    const AUTHORIZATION_HEADER_PARAM = 'authorization'
    const REALM = 'example.com'
    const NONCE = 'abcdefghijklmnopqrstuvwxyz'
    // Mock axios.request call. 
    // We want to do a minimal amount of request verification here so we can do it all via assertions at the end instead.
    let mockedResponse = (axios.request as jest.Mock).mockImplementation((config: AxiosRequestConfig) => {

      // Check if authorization header exists and starts with Digest. 
      if (AUTHORIZATION_HEADER_PARAM in config.headers && config.headers[AUTHORIZATION_HEADER_PARAM].startsWith('Digest')) {
        // Create a stream.
        let mockReadable = new Readable()
        // Immediately destory it, as it will send a close event, which will 
        mockReadable.destroy()
        return Promise.resolve({ data: mockReadable, status: 200 })
      }

      return Promise.reject({
        response: {
          data: { error: 'Unauthorized' },
          headers: { 'www-authenticate': `Digest realm="${REALM}", qop="auth", nonce="abcdefghijklmnopqrstuvwxyz", opaque="xyz"` },
          status: 401
        }
      })
    })

    let host = '192.168.0.0'
    let user = 'user'
    let pass = 'pass'
    let events: DahuaEvents = new DahuaEvents(host, user, pass, false)

    let mockDebugEventListener = jest.fn()
    events.getEventEmitter().on(events.DEBUG_EVENT_NAME, mockDebugEventListener)

    // Wait for the end of the current event loop cycle before continuing with the next line of code. 
    // TLDR wait for async process to finish above.
    await new Promise(process.nextTick)

    // Expect the mock to be called twice. Once for the 401, and again with the Digest Auth Header.
    expect(axios.request).toBeCalledTimes(2)
    // Assertions the correct digest auth parameters for the second time the request was called.
    let lastCallParams = mockedResponse.mock.lastCall
    expect(lastCallParams).toHaveLength(1)

    let axiosRequestConfig: AxiosRequestConfig = (lastCallParams[0] as AxiosRequestConfig)
    expect(axiosRequestConfig.headers).toHaveProperty(AUTHORIZATION_HEADER_PARAM)

    let digestAuthHeader: String = axiosRequestConfig.headers[AUTHORIZATION_HEADER_PARAM]
    expect(digestAuthHeader).toContain('Digest')

    // Reduce down to kv pairs.
    let digestAuthParams = digestAuthHeader.replace('Digest ', '').split(',').reduce((acc, pair) => {
      const index = pair.indexOf('=')
      const key = pair.substring(0, index)
      const value = pair.substring(index + 1)
      acc[key] = value
      return acc
    }, {} as { [key: string]: string })

    expect(digestAuthParams).toHaveProperty('username')
    expect(digestAuthParams['username']).toEqual(`"${user}"`)

    expect(digestAuthParams).toHaveProperty('realm')
    expect(digestAuthParams['realm']).toEqual(`"${REALM}"`)

    expect(digestAuthParams).toHaveProperty('nonce')
    expect(digestAuthParams['nonce']).toEqual(`"${NONCE}"`)

    expect(digestAuthParams).toHaveProperty('uri')
    expect(digestAuthParams['uri']).toEqual(`"${events['EVENTS_URI']}"`)

    expect(digestAuthParams).toHaveProperty('qop')
    expect(digestAuthParams['qop']).toEqual('"auth"')

    expect(digestAuthParams).toHaveProperty('algorithm')
    expect(digestAuthParams['algorithm']).toEqual('"MD5"')

    expect(digestAuthParams).toHaveProperty('response')
    // Testing response is hard because it relies on MD5 hashing. So here we just do some basic checks.
    let response = digestAuthParams['response'].replaceAll('"', '')
    // Check if the length is 32.
    expect(response.length).toEqual(32)
    // Check if it's a hexidecimal string.
    expect(/^[0-9a-f]+$/i.test(response)).toBe(true)

    expect(digestAuthParams).toHaveProperty('nc')
    // 00000000 + 1 = 00000001
    expect(digestAuthParams['nc']).toEqual('"00000001"')

    expect(digestAuthParams).toHaveProperty('cnonce')
    // cnonce is just 48 character long hex string generated by the crypto library.
    let cnonce = digestAuthParams['cnonce'].replaceAll('"', '')
    // Check if the length is 48.
    expect(cnonce.length).toEqual(48)
    // Check if it's a hexidecimal string.
    expect(/^[0-9a-f]+$/i.test(cnonce)).toBe(true)

    expect(mockDebugEventListener).toBeCalledTimes(4)
    expect(mockDebugEventListener.mock.calls[0][0]).toContain('401 received and www-authenticate headers, sending digest auth.')
    expect(mockDebugEventListener.mock.calls[1][0]).toContain('Successfully connected and listening to host')
    expect(mockDebugEventListener.mock.calls[2][0]).toContain('Connection response received for host')
    expect(mockDebugEventListener.mock.calls[3][0]).toContain('Socket connection closed for host:')
  })

  test('Should parse and emit Node eventName:"alarm" events when receiving video motion events', async () => {
    let mockReadable: Readable = {} as Readable
    
    // Mock axios.request call. 
    let mockedResponse = (axios.request as jest.Mock).mockImplementation((config: AxiosRequestConfig) => {
        mockReadable = new Readable()
        return Promise.resolve({ data: mockReadable, status: 200 } as AxiosResponse)
    })

    // Setup socket connection.
    let host = '192.168.0.0'
    let user = 'user'
    let pass = 'pass'
    let events: DahuaEvents = new DahuaEvents(host, user, pass, false)

    // Create mock event listener function and pass it in as the listener for alarm events.
    let mockEventListener = jest.fn()
    events.getEventEmitter().on(events.ALARM_EVENT_NAME, mockEventListener)

    let mockDebugEventListener = jest.fn()
    events.getEventEmitter().on(events.DEBUG_EVENT_NAME, mockDebugEventListener)

    // Push new alarm event to the stream.
    mockReadable.push(`myboundary
    Content-Type: text/plain
    Content-Length:36
    Code=VideoMotion;action=Stop;index=0`)
    
    // Push a different alarm event structure to the stream.
    mockReadable.push(`--myboundary

    Content-Type: text/plain

    Content-Length:77

    Code=VideoMotion;action=Start;index=5;data={
    "SmartMotionEnable" : false`)

    // Pass null to signify the end of the data.
    mockReadable.push(null)
    // Destory the stream, as it will send a close event that we handle in dahua.
    mockReadable.destroy()  
    // Wait for the end of the current event loop cycle before continuing with the next line of code. 
    // TLDR wait for async process to finish above.
    await new Promise(process.nextTick)

    // Ensure we only ever connected once.
    expect(mockedResponse).toHaveBeenCalledTimes(1)
    // Ensure we received two events to our data event listener.
    expect(mockEventListener).toHaveBeenCalledTimes(2)
    // First index of calls represents each call, second index represents argument in list of argument
    expect(mockEventListener.mock.calls[0][0] as DahuaAlarm).toStrictEqual({action:'Stop', index:"0", host: host} as DahuaAlarm)
    expect(mockEventListener.mock.calls[1][0] as DahuaAlarm).toStrictEqual({action:'Start', index:"5", host: host} as DahuaAlarm)

    expect(mockDebugEventListener.mock.calls.length).toEqual(5)
    expect(mockDebugEventListener.mock.calls[0][0]).toContain('Successfully connected and listening to host:')
    expect(mockDebugEventListener.mock.calls[1][0]).toContain('Connection response received for host:')
    expect(mockDebugEventListener.mock.calls[2][0]).toContain('Response recieved on host:')
    expect(mockDebugEventListener.mock.calls[3][0]).toContain('Response recieved on host:')
    expect(mockDebugEventListener.mock.calls[4][0]).toContain('Socket connection closed for host:')
  })

})